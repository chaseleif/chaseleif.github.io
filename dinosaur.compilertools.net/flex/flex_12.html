<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252">

<!-- This HTML file has been created by texi2html 1.44
     from /opt/src/gnu/flex-2.5.4/MISC/texinfo/flex.texi on 30 June 1997 -->

<title>Flex - a scanner generator - Multiple input buffers</title>
</head>
<body>

Go to the <a href="flex_1.html">first</a>, <a href="flex_11.html">previous</a>, <a href="flex_13.html">next</a>, <a href="flex_25.html">last</a> section, <a href="index.html">table of contents</a>.
<hr>

<h2><a name="SEC12" href="flex_12.html#SEC12">Multiple input buffers</a></h2>

<p>
Some scanners (such as those which support "include"
files) require reading from several input streams.  As
<code>flex</code> scanners do a large amount of buffering, one cannot
control where the next input will be read from by simply
writing a <code>YY_INPUT</code> which is sensitive to the scanning
context.  <code>YY_INPUT</code> is only called when the scanner reaches
the end of its buffer, which may be a long time after
scanning a statement such as an "include" which requires
switching the input source.

</p>
<p>
To negotiate these sorts of problems, <code>flex</code> provides a
mechanism for creating and switching between multiple
input buffers.  An input buffer is created by using:

</p>

<pre>YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
</pre>

<p>
which takes a <code>FILE</code> pointer and a size and creates a buffer
associated with the given file and large enough to hold
<var>size</var> characters (when in doubt, use <code>YY_BUF_SIZE</code> for the
size).  It returns a <code>YY_BUFFER_STATE</code> handle, which may
then be passed to other routines (see below).  The
<code>YY_BUFFER_STATE</code> type is a pointer to an opaque <code>struct</code>
<code>yy_buffer_state</code> structure, so you may safely initialize
YY_BUFFER_STATE variables to <samp>`((YY_BUFFER_STATE) 0)'</samp> if you
wish, and also refer to the opaque structure in order to
correctly declare input buffers in source files other than
that of your scanner.  Note that the <code>FILE</code> pointer in the
call to <code>yy_create_buffer</code> is only used as the value of <code>yyin</code>
seen by <code>YY_INPUT</code>; if you redefine <code>YY_INPUT</code> so it no longer
uses <code>yyin</code>, then you can safely pass a nil <code>FILE</code> pointer to
<code>yy_create_buffer</code>.  You select a particular buffer to scan
from using:

</p>

<pre>void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
</pre>

<p>
switches the scanner's input buffer so subsequent tokens
will come from <var>new_buffer</var>.  Note that
<samp>`yy_switch_to_buffer()'</samp> may be used by <samp>`yywrap()'</samp> to set
things up for continued scanning, instead of opening a new
file and pointing <code>yyin</code> at it.  Note also that switching
input sources via either <samp>`yy_switch_to_buffer()'</samp> or <samp>`yywrap()'</samp>
does <em>not</em> change the start condition.

</p>

<pre>void yy_delete_buffer( YY_BUFFER_STATE buffer )
</pre>

<p>
is used to reclaim the storage associated with a buffer.
You can also clear the current contents of a buffer using:

</p>

<pre>void yy_flush_buffer( YY_BUFFER_STATE buffer )
</pre>

<p>
This function discards the buffer's contents, so the next time the
scanner attempts to match a token from the buffer, it will first fill
the buffer anew using <code>YY_INPUT</code>.

</p>
<p>
<samp>`yy_new_buffer()'</samp> is an alias for <samp>`yy_create_buffer()'</samp>,
provided for compatibility with the C++ use of <code>new</code> and <code>delete</code>
for creating and destroying dynamic objects.

</p>
<p>
Finally, the <code>YY_CURRENT_BUFFER</code> macro returns a
<code>YY_BUFFER_STATE</code> handle to the current buffer.

</p>
<p>
Here is an example of using these features for writing a
scanner which expands include files (the <samp>`&lt;&lt;EOF&gt;&gt;'</samp> feature
is discussed below):

</p>

<pre>/* the "incl" state is used for picking up the name
 * of an include file
 */
%x incl

%{
#define MAX_INCLUDE_DEPTH 10
YY_BUFFER_STATE include_stack[MAX_INCLUDE_DEPTH];
int include_stack_ptr = 0;
%}

%%
include             BEGIN(incl);

[a-z]+              ECHO;
[^a-z\n]*\n?        ECHO;

&lt;incl&gt;[ \t]*      /* eat the whitespace */
&lt;incl&gt;[^ \t\n]+   { /* got the include file name */
        if ( include_stack_ptr &gt;= MAX_INCLUDE_DEPTH )
            {
            fprintf( stderr, "Includes nested too deeply" );
            exit( 1 );
            }

        include_stack[include_stack_ptr++] =
            YY_CURRENT_BUFFER;

        yyin = fopen( yytext, "r" );

        if ( ! yyin )
            error( ... );

        yy_switch_to_buffer(
            yy_create_buffer( yyin, YY_BUF_SIZE ) );

        BEGIN(INITIAL);
        }

&lt;&lt;EOF&gt;&gt; {
        if ( --include_stack_ptr &lt; 0 )
            {
            yyterminate();
            }

        else
            {
            yy_delete_buffer( YY_CURRENT_BUFFER );
            yy_switch_to_buffer(
                 include_stack[include_stack_ptr] );
            }
        }
</pre>

<p>
Three routines are available for setting up input buffers
for scanning in-memory strings instead of files.  All of
them create a new input buffer for scanning the string,
and return a corresponding <code>YY_BUFFER_STATE</code> handle (which
you should delete with <samp>`yy_delete_buffer()'</samp> when done with
it).  They also switch to the new buffer using
<samp>`yy_switch_to_buffer()'</samp>, so the next call to <samp>`yylex()'</samp> will
start scanning the string.

</p>
<dl compact="compact">

<dt><samp>`yy_scan_string(const char *str)'</samp>
</dt><dd>
scans a NUL-terminated string.

</dd><dt><samp>`yy_scan_bytes(const char *bytes, int len)'</samp>
</dt><dd>
scans <code>len</code> bytes (including possibly NUL's) starting
at location <var>bytes</var>.
</dd></dl>

<p>
Note that both of these functions create and scan a <em>copy</em>
of the string or bytes.  (This may be desirable, since
<samp>`yylex()'</samp> modifies the contents of the buffer it is
scanning.) You can avoid the copy by using:

</p>
<dl compact="compact">

<dt><samp>`yy_scan_buffer(char *base, yy_size_t size)'</samp>
</dt><dd>
which scans in place the buffer starting at <var>base</var>,
consisting of <var>size</var> bytes, the last two bytes of
which <em>must</em> be <code>YY_END_OF_BUFFER_CHAR</code> (ASCII NUL).
These last two bytes are not scanned; thus,
scanning consists of <samp>`base[0]'</samp> through <samp>`base[size-2]'</samp>,
inclusive.

If you fail to set up <var>base</var> in this manner (i.e.,
forget the final two <code>YY_END_OF_BUFFER_CHAR</code> bytes),
then <samp>`yy_scan_buffer()'</samp> returns a nil pointer instead
of creating a new input buffer.

The type <code>yy_size_t</code> is an integral type to which you
can cast an integer expression reflecting the size
of the buffer.
</dd></dl>

<hr>
Go to the <a href="flex_1.html">first</a>, <a href="flex_11.html">previous</a>, <a href="flex_13.html">next</a>, <a href="flex_25.html">last</a> section, <a href="index.html">table of contents</a>.

</body></html>
