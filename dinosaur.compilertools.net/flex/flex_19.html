<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252">

<!-- This HTML file has been created by texi2html 1.44
     from /opt/src/gnu/flex-2.5.4/MISC/texinfo/flex.texi on 30 June 1997 -->

<title>Flex - a scanner generator - Generating C++ scanners</title>
</head>
<body>

Go to the <a href="flex_1.html">first</a>, <a href="flex_18.html">previous</a>, <a href="flex_20.html">next</a>, <a href="flex_25.html">last</a> section, <a href="index.html">table of contents</a>.
<hr>

<h2><a name="SEC19" href="flex_19.html#SEC19">Generating C++ scanners</a></h2>

<p>
<code>flex</code> provides two different ways to generate scanners for
use with C++.  The first way is to simply compile a
scanner generated by <code>flex</code> using a C++ compiler instead of a C
compiler.  You should not encounter any compilations
errors (please report any you find to the email address
given in the Author section below).  You can then use C++
code in your rule actions instead of C code.  Note that
the default input source for your scanner remains <code>yyin</code>,
and default echoing is still done to <code>yyout</code>.  Both of these
remain <samp>`FILE *'</samp> variables and not C++ <code>streams</code>.

</p>
<p>
You can also use <code>flex</code> to generate a C++ scanner class, using
the <samp>`-+'</samp> option, (or, equivalently, <samp>`%option c++'</samp>), which
is automatically specified if the name of the flex executable ends
in a <samp>`+'</samp>, such as <code>flex++</code>.  When using this option, flex
defaults to generating the scanner to the file <tt>`lex.yy.cc'</tt> instead
of <tt>`lex.yy.c'</tt>.  The generated scanner includes the header file
<tt>`FlexLexer.h'</tt>, which defines the interface to two C++ classes.

</p>
<p>
The first class, <code>FlexLexer</code>, provides an abstract base
class defining the general scanner class interface.  It
provides the following member functions:

</p>
<dl compact="compact">

<dt><samp>`const char* YYText()'</samp>
</dt><dd>
returns the text of the most recently matched
token, the equivalent of <code>yytext</code>.

</dd><dt><samp>`int YYLeng()'</samp>
</dt><dd>
returns the length of the most recently matched
token, the equivalent of <code>yyleng</code>.

</dd><dt><samp>`int lineno() const'</samp>
</dt><dd>
returns the current input line number (see <samp>`%option yylineno'</samp>),
or 1 if <samp>`%option yylineno'</samp> was not used.

</dd><dt><samp>`void set_debug( int flag )'</samp>
</dt><dd>
sets the debugging flag for the scanner, equivalent to assigning to
<code>yy_flex_debug</code> (see the Options section above).  Note that you
must build the scanner using <samp>`%option debug'</samp> to include debugging
information in it.

</dd><dt><samp>`int debug() const'</samp>
</dt><dd>
returns the current setting of the debugging flag.
</dd></dl>

<p>
Also provided are member functions equivalent to
<samp>`yy_switch_to_buffer(), yy_create_buffer()'</samp> (though the
first argument is an <samp>`istream*'</samp> object pointer and not a
<samp>`FILE*'</samp>, <samp>`yy_flush_buffer()'</samp>, <samp>`yy_delete_buffer()'</samp>,
and <samp>`yyrestart()'</samp> (again, the first argument is a <samp>`istream*'</samp>
object pointer).

</p>
<p>
The second class defined in <tt>`FlexLexer.h'</tt> is <code>yyFlexLexer</code>,
which is derived from <code>FlexLexer</code>.  It defines the following
additional member functions:

</p>
<dl compact="compact">

<dt><samp>`yyFlexLexer( istream* arg_yyin = 0, ostream* arg_yyout = 0 )'</samp>
</dt><dd>
constructs a <code>yyFlexLexer</code> object using the given
streams for input and output.  If not specified,
the streams default to <code>cin</code> and <code>cout</code>, respectively.

</dd><dt><samp>`virtual int yylex()'</samp>
</dt><dd>
performs the same role is <samp>`yylex()'</samp> does for ordinary
flex scanners: it scans the input stream, consuming
tokens, until a rule's action returns a value.  If you derive a subclass
<var>S</var>
from <code>yyFlexLexer</code>
and want to access the member functions and variables of
<var>S</var>
inside <samp>`yylex()'</samp>,
then you need to use <samp>`%option yyclass="<var>S</var>"'</samp>
to inform <code>flex</code>
that you will be using that subclass instead of <code>yyFlexLexer</code>.
In this case, rather than generating <samp>`yyFlexLexer::yylex()'</samp>,
<code>flex</code> generates <samp>`<var>S</var>::yylex()'</samp>
(and also generates a dummy <samp>`yyFlexLexer::yylex()'</samp>
that calls <samp>`yyFlexLexer::LexerError()'</samp>
if called).

</dd><dt><samp>`virtual void switch_streams(istream* new_in = 0, ostream* new_out = 0)'</samp>
</dt><dd>
reassigns <code>yyin</code> to <code>new_in</code>
(if non-nil)
and <code>yyout</code> to <code>new_out</code>
(ditto), deleting the previous input buffer if <code>yyin</code>
is reassigned.

</dd><dt><samp>`int yylex( istream* new_in = 0, ostream* new_out = 0 )'</samp>
</dt><dd>
first switches the input streams via <samp>`switch_streams( new_in, new_out )'</samp>
and then returns the value of <samp>`yylex()'</samp>.
</dd></dl>

<p>
In addition, <code>yyFlexLexer</code> defines the following protected
virtual functions which you can redefine in derived
classes to tailor the scanner:

</p>
<dl compact="compact">

<dt><samp>`virtual int LexerInput( char* buf, int max_size )'</samp>
</dt><dd>
reads up to <samp>`max_size'</samp> characters into <var>buf</var> and
returns the number of characters read.  To indicate
end-of-input, return 0 characters.  Note that
"interactive" scanners (see the <samp>`-B'</samp> and <samp>`-I'</samp> flags)
define the macro <code>YY_INTERACTIVE</code>.  If you redefine
<code>LexerInput()</code> and need to take different actions
depending on whether or not the scanner might be
scanning an interactive input source, you can test
for the presence of this name via <samp>`#ifdef'</samp>.

</dd><dt><samp>`virtual void LexerOutput( const char* buf, int size )'</samp>
</dt><dd>
writes out <var>size</var> characters from the buffer <var>buf</var>,
which, while NUL-terminated, may also contain
"internal" NUL's if the scanner's rules can match
text with NUL's in them.

</dd><dt><samp>`virtual void LexerError( const char* msg )'</samp>
</dt><dd>
reports a fatal error message.  The default version
of this function writes the message to the stream
<code>cerr</code> and exits.
</dd></dl>

<p>
Note that a <code>yyFlexLexer</code> object contains its <em>entire</em>
scanning state.  Thus you can use such objects to create
reentrant scanners.  You can instantiate multiple instances of
the same <code>yyFlexLexer</code> class, and you can also combine
multiple C++ scanner classes together in the same program
using the <samp>`-P'</samp> option discussed above.
Finally, note that the <samp>`%array'</samp> feature is not available to
C++ scanner classes; you must use <samp>`%pointer'</samp> (the default).

</p>
<p>
Here is an example of a simple C++ scanner:

</p>

<pre>    // An example of using the flex C++ scanner class.

%{
int mylineno = 0;
%}

string  \"[^\n"]+\"

ws      [ \t]+

alpha   [A-Za-z]
dig     [0-9]
name    ({alpha}|{dig}|\$)({alpha}|{dig}|[_.\-/$])*
num1    [-+]?{dig}+\.?([eE][-+]?{dig}+)?
num2    [-+]?{dig}*\.{dig}+([eE][-+]?{dig}+)?
number  {num1}|{num2}

%%

{ws}    /* skip blanks and tabs */

"/*"    {
        int c;

        while((c = yyinput()) != 0)
            {
            if(c == '\n')
                ++mylineno;

            else if(c == '*')
                {
                if((c = yyinput()) == '/')
                    break;
                else
                    unput(c);
                }
            }
        }

{number}  cout &lt;&lt; "number " &lt;&lt; YYText() &lt;&lt; '\n';

\n        mylineno++;

{name}    cout &lt;&lt; "name " &lt;&lt; YYText() &lt;&lt; '\n';

{string}  cout &lt;&lt; "string " &lt;&lt; YYText() &lt;&lt; '\n';

%%

Version 2.5               December 1994                        44

int main( int /* argc */, char** /* argv */ )
    {
    FlexLexer* lexer = new yyFlexLexer;
    while(lexer-&gt;yylex() != 0)
        ;
    return 0;
    }
</pre>

<p>
If you want to create multiple (different) lexer classes,
you use the <samp>`-P'</samp> flag (or the <samp>`prefix='</samp> option) to rename each
<code>yyFlexLexer</code> to some other <code>xxFlexLexer</code>.  You then can
include <samp>`&lt;FlexLexer.h&gt;'</samp> in your other sources once per lexer
class, first renaming <code>yyFlexLexer</code> as follows:

</p>

<pre>#undef yyFlexLexer
#define yyFlexLexer xxFlexLexer
#include &lt;FlexLexer.h&gt;

#undef yyFlexLexer
#define yyFlexLexer zzFlexLexer
#include &lt;FlexLexer.h&gt;
</pre>

<p>
if, for example, you used <samp>`%option prefix="xx"'</samp> for one of
your scanners and <samp>`%option prefix="zz"'</samp> for the other.

</p>
<p>
IMPORTANT: the present form of the scanning class is
<em>experimental</em> and may change considerably between major
releases.

</p>
<hr>
Go to the <a href="flex_1.html">first</a>, <a href="flex_18.html">previous</a>, <a href="flex_20.html">next</a>, <a href="flex_25.html">last</a> section, <a href="index.html">table of contents</a>.

</body></html>
