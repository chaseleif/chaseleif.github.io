<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252">

<!-- This HTML file has been created by texi2html 1.44
     from /opt/src/gnu/flex-2.5.4/MISC/texinfo/flex.texi on 30 June 1997 -->

<title>Flex - a scanner generator - Start conditions</title>
</head>
<body>

Go to the <a href="flex_1.html">first</a>, <a href="flex_10.html">previous</a>, <a href="flex_12.html">next</a>, <a href="flex_25.html">last</a> section, <a href="index.html">table of contents</a>.
<hr>

<h2><a name="SEC11" href="flex_11.html#SEC11">Start conditions</a></h2>

<p>
<code>flex</code> provides a mechanism for conditionally activating
rules.  Any rule whose pattern is prefixed with "&lt;sc&gt;"
will only be active when the scanner is in the start
condition named "sc".  For example,

</p>

<pre>&lt;STRING&gt;[^"]*        { /* eat up the string body ... */
            ...
            }
</pre>

<p>
will be active only when the scanner is in the "STRING"
start condition, and

</p>

<pre>&lt;INITIAL,STRING,QUOTE&gt;\.        { /* handle an escape ... */
            ...
            }
</pre>

<p>
will be active only when the current start condition is
either "INITIAL", "STRING", or "QUOTE".

</p>
<p>
Start conditions are declared in the definitions (first)
section of the input using unindented lines beginning with
either <samp>`%s'</samp> or <samp>`%x'</samp> followed by a list of names.  The former
declares <em>inclusive</em> start conditions, the latter <em>exclusive</em>
start conditions.  A start condition is activated using
the <code>BEGIN</code> action.  Until the next <code>BEGIN</code> action is
executed, rules with the given start condition will be active
and rules with other start conditions will be inactive.
If the start condition is <em>inclusive</em>, then rules with no
start conditions at all will also be active.  If it is
<em>exclusive</em>, then <em>only</em> rules qualified with the start
condition will be active.  A set of rules contingent on the
same exclusive start condition describe a scanner which is
independent of any of the other rules in the <code>flex</code> input.
Because of this, exclusive start conditions make it easy
to specify "mini-scanners" which scan portions of the
input that are syntactically different from the rest
(e.g., comments).

</p>
<p>
If the distinction between inclusive and exclusive start
conditions is still a little vague, here's a simple
example illustrating the connection between the two.  The set
of rules:

</p>

<pre>%s example
%%

&lt;example&gt;foo   do_something();

bar            something_else();
</pre>

<p>
is equivalent to

</p>

<pre>%x example
%%

&lt;example&gt;foo   do_something();

&lt;INITIAL,example&gt;bar    something_else();
</pre>

<p>
Without the <samp>`&lt;INITIAL,example&gt;'</samp> qualifier, the <samp>`bar'</samp> pattern
in the second example wouldn't be active (i.e., couldn't match) when
in start condition <samp>`example'</samp>.  If we just used <samp>`&lt;example&gt;'</samp>
to qualify <samp>`bar'</samp>, though, then it would only be active in
<samp>`example'</samp> and not in <code>INITIAL</code>, while in the first example
it's active in both, because in the first example the <samp>`example'</samp>
starting condition is an <em>inclusive</em> (<samp>`%s'</samp>) start condition.

</p>
<p>
Also note that the special start-condition specifier <samp>`&lt;*&gt;'</samp>
matches every start condition.  Thus, the above example
could also have been written;

</p>

<pre>%x example
%%

&lt;example&gt;foo   do_something();

&lt;*&gt;bar    something_else();
</pre>

<p>
The default rule (to <samp>`ECHO'</samp> any unmatched character) remains
active in start conditions.  It is equivalent to:

</p>

<pre>&lt;*&gt;.|\\n     ECHO;
</pre>

<p>
<samp>`BEGIN(0)'</samp> returns to the original state where only the
rules with no start conditions are active.  This state can
also be referred to as the start-condition "INITIAL", so
<samp>`BEGIN(INITIAL)'</samp> is equivalent to <samp>`BEGIN(0)'</samp>.  (The
parentheses around the start condition name are not required but
are considered good style.)

</p>
<p>
<code>BEGIN</code> actions can also be given as indented code at the
beginning of the rules section.  For example, the
following will cause the scanner to enter the "SPECIAL" start
condition whenever <samp>`yylex()'</samp> is called and the global
variable <code>enter_special</code> is true:

</p>

<pre>        int enter_special;

%x SPECIAL
%%
        if ( enter_special )
            BEGIN(SPECIAL);

&lt;SPECIAL&gt;blahblahblah
...more rules follow...
</pre>

<p>
To illustrate the uses of start conditions, here is a
scanner which provides two different interpretations of a
string like "123.456".  By default it will treat it as as
three tokens, the integer "123", a dot ('.'), and the
integer "456".  But if the string is preceded earlier in
the line by the string "expect-floats" it will treat it as
a single token, the floating-point number 123.456:

</p>

<pre>%{
#include &lt;math.h&gt;
%}
%s expect

%%
expect-floats        BEGIN(expect);

&lt;expect&gt;[0-9]+"."[0-9]+      {
            printf( "found a float, = %f\n",
                    atof( yytext ) );
            }
&lt;expect&gt;\n           {
            /* that's the end of the line, so
             * we need another "expect-number"
             * before we'll recognize any more
             * numbers
             */
            BEGIN(INITIAL);
            }

[0-9]+      {

Version 2.5               December 1994                        18

            printf( "found an integer, = %d\n",
                    atoi( yytext ) );
            }

"."         printf( "found a dot\n" );
</pre>

<p>
Here is a scanner which recognizes (and discards) C
comments while maintaining a count of the current input line.

</p>

<pre>%x comment
%%
        int line_num = 1;

"/*"         BEGIN(comment);

&lt;comment&gt;[^*\n]*        /* eat anything that's not a '*' */
&lt;comment&gt;"*"+[^*/\n]*   /* eat up '*'s not followed by '/'s */
&lt;comment&gt;\n             ++line_num;
&lt;comment&gt;"*"+"/"        BEGIN(INITIAL);
</pre>

<p>
This scanner goes to a bit of trouble to match as much
text as possible with each rule.  In general, when
attempting to write a high-speed scanner try to match as
much possible in each rule, as it's a big win.

</p>
<p>
Note that start-conditions names are really integer values
and can be stored as such.  Thus, the above could be
extended in the following fashion:

</p>

<pre>%x comment foo
%%
        int line_num = 1;
        int comment_caller;

"/*"         {
             comment_caller = INITIAL;
             BEGIN(comment);
             }

...

&lt;foo&gt;"/*"    {
             comment_caller = foo;
             BEGIN(comment);
             }

&lt;comment&gt;[^*\n]*        /* eat anything that's not a '*' */
&lt;comment&gt;"*"+[^*/\n]*   /* eat up '*'s not followed by '/'s */
&lt;comment&gt;\n             ++line_num;
&lt;comment&gt;"*"+"/"        BEGIN(comment_caller);
</pre>

<p>
Furthermore, you can access the current start condition
using the integer-valued <code>YY_START</code> macro.  For example, the
above assignments to <code>comment_caller</code> could instead be
written

</p>

<pre>comment_caller = YY_START;
</pre>

<p>
Flex provides <code>YYSTATE</code> as an alias for <code>YY_START</code> (since that
is what's used by AT&amp;T <code>lex</code>).

</p>
<p>
Note that start conditions do not have their own
name-space; %s's and %x's declare names in the same fashion as
#define's.

</p>
<p>
Finally, here's an example of how to match C-style quoted
strings using exclusive start conditions, including
expanded escape sequences (but not including checking for
a string that's too long):

</p>

<pre>%x str

%%
        char string_buf[MAX_STR_CONST];
        char *string_buf_ptr;

\"      string_buf_ptr = string_buf; BEGIN(str);

&lt;str&gt;\"        { /* saw closing quote - all done */
        BEGIN(INITIAL);
        *string_buf_ptr = '\0';
        /* return string constant token type and
         * value to parser
         */
        }

&lt;str&gt;\n        {
        /* error - unterminated string constant */
        /* generate error message */
        }

&lt;str&gt;\\[0-7]{1,3} {
        /* octal escape sequence */
        int result;

        (void) sscanf( yytext + 1, "%o", &amp;result );

        if ( result &gt; 0xff )
                /* error, constant is out-of-bounds */

        *string_buf_ptr++ = result;
        }

&lt;str&gt;\\[0-9]+ {
        /* generate error - bad escape sequence; something
         * like '\48' or '\0777777'
         */
        }

&lt;str&gt;\\n  *string_buf_ptr++ = '\n';
&lt;str&gt;\\t  *string_buf_ptr++ = '\t';
&lt;str&gt;\\r  *string_buf_ptr++ = '\r';
&lt;str&gt;\\b  *string_buf_ptr++ = '\b';
&lt;str&gt;\\f  *string_buf_ptr++ = '\f';

&lt;str&gt;\\(.|\n)  *string_buf_ptr++ = yytext[1];

&lt;str&gt;[^\\\n\"]+        {
        char *yptr = yytext;

        while ( *yptr )
                *string_buf_ptr++ = *yptr++;
        }
</pre>

<p>
Often, such as in some of the examples above, you wind up
writing a whole bunch of rules all preceded by the same
start condition(s).  Flex makes this a little easier and
cleaner by introducing a notion of start condition <strong>scope</strong>.
A start condition scope is begun with:

</p>

<pre>&lt;SCs&gt;{
</pre>

<p>
where SCs is a list of one or more start conditions.
Inside the start condition scope, every rule automatically
has the prefix <samp>`&lt;SCs&gt;'</samp> applied to it, until a <samp>`}'</samp> which
matches the initial <samp>`{'</samp>.  So, for example,

</p>

<pre>&lt;ESC&gt;{
    "\\n"   return '\n';
    "\\r"   return '\r';
    "\\f"   return '\f';
    "\\0"   return '\0';
}
</pre>

<p>
is equivalent to:

</p>

<pre>&lt;ESC&gt;"\\n"  return '\n';
&lt;ESC&gt;"\\r"  return '\r';
&lt;ESC&gt;"\\f"  return '\f';
&lt;ESC&gt;"\\0"  return '\0';
</pre>

<p>
Start condition scopes may be nested.

</p>
<p>
Three routines are available for manipulating stacks of
start conditions:

</p>
<dl compact="compact">

<dt><samp>`void yy_push_state(int new_state)'</samp>
</dt><dd>
pushes the current start condition onto the top of
the start condition stack and switches to <var>new_state</var>
as though you had used <samp>`BEGIN new_state'</samp> (recall that
start condition names are also integers).

</dd><dt><samp>`void yy_pop_state()'</samp>
</dt><dd>
pops the top of the stack and switches to it via
<code>BEGIN</code>.

</dd><dt><samp>`int yy_top_state()'</samp>
</dt><dd>
returns the top of the stack without altering the
stack's contents.
</dd></dl>

<p>
The start condition stack grows dynamically and so has no
built-in size limitation.  If memory is exhausted, program
execution aborts.

</p>
<p>
To use start condition stacks, your scanner must include a
<samp>`%option stack'</samp> directive (see Options below).

</p>
<hr>
Go to the <a href="flex_1.html">first</a>, <a href="flex_10.html">previous</a>, <a href="flex_12.html">next</a>, <a href="flex_25.html">last</a> section, <a href="index.html">table of contents</a>.

</body></html>
