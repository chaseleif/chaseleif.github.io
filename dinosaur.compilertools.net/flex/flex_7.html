<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252">

<!-- This HTML file has been created by texi2html 1.44
     from /opt/src/gnu/flex-2.5.4/MISC/texinfo/flex.texi on 30 June 1997 -->

<title>Flex - a scanner generator - Patterns</title>
</head>
<body>

Go to the <a href="flex_1.html">first</a>, <a href="flex_6.html">previous</a>, <a href="flex_8.html">next</a>, <a href="flex_25.html">last</a> section, <a href="index.html">table of contents</a>.
<hr>

<h2><a name="SEC7" href="flex_7.html#SEC7">Patterns</a></h2>

<p>
The patterns in the input are written using an extended
set of regular expressions.  These are:

</p>
<dl compact="compact">

<dt><samp>`x'</samp>
</dt><dd>
match the character <samp>`x'</samp>
</dd><dt><samp>`.'</samp>
</dt><dd>
any character (byte) except newline
</dd><dt><samp>`[xyz]'</samp>
</dt><dd>
a "character class"; in this case, the pattern
matches either an <samp>`x'</samp>, a <samp>`y'</samp>, or a <samp>`z'</samp>
</dd><dt><samp>`[abj-oZ]'</samp>
</dt><dd>
a "character class" with a range in it; matches
an <samp>`a'</samp>, a <samp>`b'</samp>, any letter from <samp>`j'</samp> through <samp>`o'</samp>,
or a <samp>`Z'</samp>
</dd><dt><samp>`[^A-Z]'</samp>
</dt><dd>
a "negated character class", i.e., any character
but those in the class.  In this case, any
character EXCEPT an uppercase letter.
</dd><dt><samp>`[^A-Z\n]'</samp>
</dt><dd>
any character EXCEPT an uppercase letter or
a newline
</dd><dt><samp>`<var>r</var>*'</samp>
</dt><dd>
zero or more <var>r</var>'s, where <var>r</var> is any regular expression
</dd><dt><samp>`<var>r</var>+'</samp>
</dt><dd>
one or more <var>r</var>'s
</dd><dt><samp>`<var>r</var>?'</samp>
</dt><dd>
zero or one <var>r</var>'s (that is, "an optional <var>r</var>")
</dd><dt><samp>`<var>r</var>{2,5}'</samp>
</dt><dd>
anywhere from two to five <var>r</var>'s
</dd><dt><samp>`<var>r</var>{2,}'</samp>
</dt><dd>
two or more <var>r</var>'s
</dd><dt><samp>`<var>r</var>{4}'</samp>
</dt><dd>
exactly 4 <var>r</var>'s
</dd><dt><samp>`{<var>name</var>}'</samp>
</dt><dd>
the expansion of the "<var>name</var>" definition
(see above)
</dd><dt><samp>`"[xyz]\"foo"'</samp>
</dt><dd>
the literal string: <samp>`[xyz]"foo'</samp>
</dd><dt><samp>`\<var>x</var>'</samp>
</dt><dd>
if <var>x</var> is an <samp>`a'</samp>, <samp>`b'</samp>, <samp>`f'</samp>, <samp>`n'</samp>, <samp>`r'</samp>, <samp>`t'</samp>, or <samp>`v'</samp>,
then the ANSI-C interpretation of \<var>x</var>.
Otherwise, a literal <samp>`<var>x</var>'</samp> (used to escape
operators such as <samp>`*'</samp>)
</dd><dt><samp>`\0'</samp>
</dt><dd>
a NUL character (ASCII code 0)
</dd><dt><samp>`\123'</samp>
</dt><dd>
the character with octal value 123
</dd><dt><samp>`\x2a'</samp>
</dt><dd>
the character with hexadecimal value <code>2a</code>
</dd><dt><samp>`(<var>r</var>)'</samp>
</dt><dd>
match an <var>r</var>; parentheses are used to override
precedence (see below)
</dd><dt><samp>`<var>r</var><var>s</var>'</samp>
</dt><dd>
the regular expression <var>r</var> followed by the
regular expression <var>s</var>; called "concatenation"
</dd><dt><samp>`<var>r</var>|<var>s</var>'</samp>
</dt><dd>
either an <var>r</var> or an <var>s</var>
</dd><dt><samp>`<var>r</var>/<var>s</var>'</samp>
</dt><dd>
an <var>r</var> but only if it is followed by an <var>s</var>.  The text
matched by <var>s</var> is included when determining whether this rule is
the <strong>longest match</strong>, but is then returned to the input before
the action is executed.  So the action only sees the text matched
by <var>r</var>.  This type of pattern is called <strong>trailing context</strong>.
(There are some combinations of <samp>`<var>r</var>/<var>s</var>'</samp> that <code>flex</code>
cannot match correctly; see notes in the Deficiencies / Bugs section
below regarding "dangerous trailing context".)
</dd><dt><samp>`^<var>r</var>'</samp>
</dt><dd>
an <var>r</var>, but only at the beginning of a line (i.e.,
which just starting to scan, or right after a
newline has been scanned).
</dd><dt><samp>`<var>r</var>$'</samp>
</dt><dd>
an <var>r</var>, but only at the end of a line (i.e., just
before a newline).  Equivalent to "<var>r</var>/\n".

Note that flex's notion of "newline" is exactly
whatever the C compiler used to compile flex
interprets '\n' as; in particular, on some DOS
systems you must either filter out \r's in the
input yourself, or explicitly use <var>r</var>/\r\n for "r$".
</dd><dt><samp>`&lt;<var>s</var>&gt;<var>r</var>'</samp>
</dt><dd>
an <var>r</var>, but only in start condition <var>s</var> (see
below for discussion of start conditions)
&lt;<var>s1</var>,<var>s2</var>,<var>s3</var>&gt;<var>r</var>
same, but in any of start conditions <var>s1</var>,
<var>s2</var>, or <var>s3</var>
</dd><dt><samp>`&lt;*&gt;<var>r</var>'</samp>
</dt><dd>
an <var>r</var> in any start condition, even an exclusive one.
</dd><dt><samp>`&lt;&lt;EOF&gt;&gt;'</samp>
</dt><dd>
an end-of-file
&lt;<var>s1</var>,<var>s2</var>&gt;&lt;&lt;EOF&gt;&gt;
an end-of-file when in start condition <var>s1</var> or <var>s2</var>
</dd></dl>

<p>
Note that inside of a character class, all regular
expression operators lose their special meaning except escape
('\') and the character class operators, '-', ']', and, at
the beginning of the class, '^'.

</p>
<p>
The regular expressions listed above are grouped according
to precedence, from highest precedence at the top to
lowest at the bottom.  Those grouped together have equal
precedence.  For example,

</p>

<pre>foo|bar*
</pre>

<p>
is the same as

</p>

<pre>(foo)|(ba(r*))
</pre>

<p>
since the '*' operator has higher precedence than
concatenation, and concatenation higher than alternation ('|').
This pattern therefore matches <em>either</em> the string "foo" <em>or</em>
the string "ba" followed by zero-or-more r's.  To match
"foo" or zero-or-more "bar"'s, use:

</p>

<pre>foo|(bar)*
</pre>

<p>
and to match zero-or-more "foo"'s-or-"bar"'s:

</p>

<pre>(foo|bar)*
</pre>

<p>
In addition to characters and ranges of characters,
character classes can also contain character class
<strong>expressions</strong>.  These are expressions enclosed inside <samp>`['</samp>: and <samp>`:'</samp>]
delimiters (which themselves must appear between the '['
and ']' of the character class; other elements may occur
inside the character class, too).  The valid expressions
are:

</p>

<pre>[:alnum:] [:alpha:] [:blank:]
[:cntrl:] [:digit:] [:graph:]
[:lower:] [:print:] [:punct:]
[:space:] [:upper:] [:xdigit:]
</pre>

<p>
These expressions all designate a set of characters
equivalent to the corresponding standard C <samp>`isXXX'</samp> function.  For
example, <samp>`[:alnum:]'</samp> designates those characters for which
<samp>`isalnum()'</samp> returns true - i.e., any alphabetic or numeric.
Some systems don't provide <samp>`isblank()'</samp>, so flex defines
<samp>`[:blank:]'</samp> as a blank or a tab.

</p>
<p>
For example, the following character classes are all
equivalent:

</p>

<pre>[[:alnum:]]
[[:alpha:][:digit:]
[[:alpha:]0-9]
[a-zA-Z0-9]
</pre>

<p>
If your scanner is case-insensitive (the <samp>`-i'</samp> flag), then
<samp>`[:upper:]'</samp> and <samp>`[:lower:]'</samp> are equivalent to <samp>`[:alpha:]'</samp>.

</p>
<p>
Some notes on patterns:

</p>

<ul>
<li>

A negated character class such as the example
"[^A-Z]" above <em>will match a newline</em> unless "\n" (or an
equivalent escape sequence) is one of the
characters explicitly present in the negated character
class (e.g., "[^A-Z\n]").  This is unlike how many
other regular expression tools treat negated
character classes, but unfortunately the inconsistency
is historically entrenched.  Matching newlines
means that a pattern like [^"]* can match the
entire input unless there's another quote in the
input.

</li><li>

A rule can have at most one instance of trailing
context (the '/' operator or the '$' operator).
The start condition, '^', and "&lt;&lt;EOF&gt;&gt;" patterns
can only occur at the beginning of a pattern, and,
as well as with '/' and '$', cannot be grouped
inside parentheses.  A '^' which does not occur at
the beginning of a rule or a '$' which does not
occur at the end of a rule loses its special
properties and is treated as a normal character.

The following are illegal:

<pre>foo/bar$
&lt;sc1&gt;foo&lt;sc2&gt;bar
</pre>

Note that the first of these, can be written
"foo/bar\n".

The following will result in '$' or '^' being
treated as a normal character:

<pre>foo|(bar$)
foo|^bar
</pre>

If what's wanted is a "foo" or a
bar-followed-by-a-newline, the following could be used (the special
'|' action is explained below):

<pre>foo      |
bar$     /* action goes here */
</pre>

A similar trick will work for matching a foo or a
bar-at-the-beginning-of-a-line.
</li></ul>

<hr>
Go to the <a href="flex_1.html">first</a>, <a href="flex_6.html">previous</a>, <a href="flex_8.html">next</a>, <a href="flex_25.html">last</a> section, <a href="index.html">table of contents</a>.

</body></html>
